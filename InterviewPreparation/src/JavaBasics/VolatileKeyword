The `volatile` keyword in Java is used to ensure **visibility** of changes to variables across
threads. Itâ€™s a lightweight synchronization mechanism that tells the JVM:

> â€œHey, donâ€™t cache this variableâ€”always read and write it directly from main memory.â€

---

### ğŸ” Why It Matters

In a multithreaded environment, each thread may keep a **local copy** of variables for performance.
Without `volatile`, one threadâ€™s update might not be visible to others immediately,
leading to **data inconsistency**.

---

### âœ… What `volatile` Guarantees

- **Visibility**: Changes made by one thread are immediately visible to others.
- **No caching**: The variable is always read from and written to main memory.
- **No reordering**: Prevents compiler and CPU from reordering instructions that involve the volatile variable.

---

### âš ï¸ What It Does *Not* Guarantee

- **Atomicity**: Operations like `counter++` are *not* atomic even if `counter` is volatile.
- **Mutual exclusion**: It doesnâ€™t prevent race conditionsâ€” use `synchronized` or `AtomicInteger`
for that.

---

### ğŸ§  Example

```java
class SharedData {
    private volatile boolean flag = false;

    public void setFlagTrue() {
        flag = true;
    }

    public boolean isFlagTrue() {
        return flag;
    }
}
```

Here, if one thread sets `flag = true`, other threads will see the change immediatelyâ€”even if theyâ€™re running on different cores.

---

Want to explore how `volatile` compares with `synchronized`, or dive into real-world use cases like double-checked locking or visibility bugs? I can walk you through those next.
