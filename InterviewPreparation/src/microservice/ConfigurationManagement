## ⚙️ What Is Configuration Management?

In microservices, each service may have its own:
- Database credentials
- API keys
- Feature flags
- Environment-specific settings (dev, test, prod)

**Configuration management** ensures these settings are:
- Centralized
- Versioned
- Secure
- Dynamically refreshable

---

## 🧱 Common Strategies

### 1. **Spring Cloud Config Server**
A centralized server that serves configuration properties to microservices.

#### 🔹 How It Works:
- Configs stored in Git or local file system
- Services fetch config via REST or auto-bind on startup
- Supports dynamic refresh with `@RefreshScope`

#### 🔹 Example:
```yaml
# application.yml in Git
server.port: 8081
spring.datasource.url: jdbc:mysql://localhost:3306/userdb
```

```java
@RefreshScope
@RestController
public class ConfigController {
    @Value("${server.port}")
    private String port;

    @GetMapping("/port")
    public String getPort() {
        return "Running on port: " + port;
    }
}
```

---

### 2. **Environment Variables**
Used in containerized deployments (e.g., Docker, Kubernetes).

- Injected at runtime
- Secure and isolated per environment
- Ideal for secrets and credentials

```bash
export DB_URL=jdbc:mysql://localhost:3306/userdb
```

```java
@Value("${DB_URL}")
private String dbUrl;
```

---

### 3. **Kubernetes ConfigMaps & Secrets**
For cloud-native setups, Kubernetes offers:

- **ConfigMaps**: Non-sensitive config data
- **Secrets**: Encrypted sensitive data (e.g., passwords, tokens)

Mounted as environment variables or volumes.

---

### 4. **Service Discovery + Config**
Tools like **Consul** or **Eureka** can also store lightweight config data alongside service metadata.

---

### 5. **Feature Flags**
Use tools like **Unleash**, **FF4J**, or **LaunchDarkly** to toggle features dynamically without redeploying.

---

## 🔐 Best Practices

| Practice                     | Why It Matters                          |
|-----------------------------|------------------------------------------|
| 🔒 Externalize configs       | Avoid hardcoding sensitive data          |
| 📁 Use version control       | Track changes and rollback safely        |
| 🔄 Support dynamic refresh   | Update configs without restarting        |
| 🧪 Separate environments     | Isolate dev, test, prod configs          |
| 🧩 Use profiles              | Spring profiles (`dev`, `prod`, etc.)    |

---

## 🧠 Real-World Setup

In a Spring Boot microservices ecosystem:
- Use **Spring Cloud Config Server** backed by Git
- Secure secrets with **Vault or Kubernetes Secrets**
- Enable **actuator refresh endpoints**
- Combine with **Eureka + Gateway** for full control

---

Would you like a working example of Spring Cloud Config Server with Git integration and dynamic refresh? I can walk you through the setup and code.
