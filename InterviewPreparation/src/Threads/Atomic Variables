## âš›ï¸ What Are Atomic Variables?

## âš™ï¸ What is **Atomicity**?

**Atomicity** means that an operation is performed as a **single, indivisible unit** â€” it either
**completes fully** or **does not happen at all**, with **no intermediate state visible** to other
threads.

In multithreaded environments, atomicity ensures that **shared variables are updated safely**,
without race conditions.

---

## ğŸ§  Why It Matters

Without atomicity, two threads updating the same variable might **interleave**, leading to
**inconsistent or corrupted state**.

---

## âœ… Example Without Atomicity (Race Condition)

```java
class Counter {
    int count = 0;

    public void increment() {
        count++; // Not atomic: internally it's read-modify-write
    }
}
```

If two threads call `increment()` simultaneously, they might both read `count = 0`, increment it,
and write back `1` â€” even though it should be `2`.

---

## âœ… Example With Atomicity Using `AtomicInteger`

```java
import java.util.concurrent.atomic.AtomicInteger;

class AtomicCounter {
    AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet(); // Atomic: thread-safe
    }
}
```

Here, `incrementAndGet()` is **atomic** â€” it guarantees that no two threads can interfere with each
other during the update.

---

## ğŸ” Behind the Scenes

Atomic classes like `AtomicInteger`, `AtomicLong`, `AtomicReference` use **low-level CPU instructions**
(like CAS â€” Compare-And-Swap) to ensure atomicity **without locking**.

---

## ğŸ§ª Real-World Use Case

In a reactive microservice (e.g., using Quarkus + WebFlux), you might use `AtomicInteger` to track active requests or retries safely across threads:

```java
AtomicInteger activeRequests = new AtomicInteger(0);

public Uni<Response> handleRequest() {
    activeRequests.incrementAndGet();
    return process()
        .onTermination().invoke(() -> activeRequests.decrementAndGet());
}

**Atomic variables** are special classes in Java that allow **thread-safe operations on single
variables** without using explicit synchronization (`synchronized` blocks or locks).

They are part of the `java.util.concurrent.atomic` package and include:
- `AtomicInteger`
- `AtomicLong`
- `AtomicBoolean`
- `AtomicReference<T>`

These classes use **low-level CPU instructions** (like CAS â€” Compare-And-Swap) to ensure atomicity.

---

## ğŸ§  Why Are They Needed?

In a multi-threaded environment:
- Multiple threads may try to **read/write the same variable** at the same time.
- Without proper synchronization, this leads to **race conditions**, **inconsistent data**,
or **lost updates**.

Atomic variables solve this by:
- Ensuring **atomicity**: operations happen as a single, indivisible step.
- Avoiding **locks**, which can be expensive and lead to contention.

---

## ğŸ”§ Example: Without AtomicInteger (Problematic)

```java
class Counter {
    int count = 0;

    public void increment() {
        count++; // Not thread-safe!
    }
}
```

Multiple threads calling `increment()` may corrupt the value of `count`.

---

## âœ… Example: With AtomicInteger (Thread-Safe)

```java
import java.util.concurrent.atomic.AtomicInteger;

class AtomicCounter {
    AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet(); // Atomic and thread-safe
    }

    public int getCount() {
        return count.get();
    }
}
```

Here, `incrementAndGet()` ensures that the increment operation is atomic â€” no two threads can interfere with each other.

---

## ğŸ” Common Atomic Operations

| Method | Description |
|--------|-------------|
| `get()` | Returns the current value |
| `set(int newValue)` | Sets a new value |
| `incrementAndGet()` | Atomically increments and returns new value |
| `compareAndSet(expected, update)` | Atomically sets value if current equals expected |

---

## ğŸ§© Real-World Use Case

Imagine a leaderboard system where multiple threads update a user's score:
- Using `AtomicInteger` ensures that score updates are safe and consistent.
- No need for synchronized blocks or locks â€” better performance under load.