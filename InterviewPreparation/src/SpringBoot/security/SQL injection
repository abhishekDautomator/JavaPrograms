## ğŸ’‰ What Is Injection?

Injection happens when **untrusted input** is sent to a database or interpreter **without proper
validation or sanitization**, allowing attackers to manipulate queries and access unauthorized
data.

---

## ğŸ§¨ SQL Injection: Classic Example

### ğŸ”¹ Vulnerable Code
```java
String query = "SELECT * FROM users WHERE username = '" + userInput + "'";
```

If `userInput = ' OR '1'='1`, the query becomes:
```sql
SELECT * FROM users WHERE username = '' OR '1'='1'
```

ğŸ”´ This returns **all users**, bypassing authentication!

### ğŸ”¹ Attack Impact
- Bypass login
- Dump entire database
- Delete or modify data
- Execute admin operations

---

## ğŸ§¨ NoSQL Injection: Modern Variant

### ğŸ”¹ MongoDB Example (JavaScript-style query)
```js
db.users.find({ username: userInput })
```

If `userInput = { "$ne": null }`, the query becomes:
```js
db.users.find({ username: { "$ne": null } })
```

ğŸ”´ This matches **all users**, again bypassing logic.

### ğŸ”¹ Attack Impact
- Unauthorized access
- Data leakage
- Logic manipulation

---

## ğŸ›¡ï¸ How to Prevent Injection

| Technique                     | Description |
|------------------------------|-------------|
| âœ… **Parameterized Queries** | Use `PreparedStatement` in SQL or query builders in NoSQL |
| âœ… **Input Validation**      | Whitelist expected formats (e.g., email, username) |
| âœ… **Escaping Input**        | Escape special characters if dynamic queries are unavoidable |
| âœ… **Use ORM/ODM Safely**    | Hibernate, JPA, Spring Data MongoDB reduce direct query risks |
| âœ… **Security Testing**      | Use tools like OWASP ZAP, Burp Suite, or Snyk to scan for vulnerabilities |

---

## ğŸ” Spring Boot Example: Safe SQL

```java
@Query("SELECT u FROM User u WHERE u.username = :username")
User findByUsername(@Param("username") String username);
```

âœ… Uses JPQL with parameter binding â€” safe from injection.

JPQL â€” **Java Persistence Query Language** â€” is a powerful, object-oriented query language used
in **JPA (Java Persistence API)** to interact with relational databases using **entity objects**,
not raw tables.

Letâ€™s break it down clearly:

---

## ğŸ§  What Is JPQL?

- JPQL is **similar to SQL**, but it works with **Java classes and fields**, not database tables and columns.
- Itâ€™s **database-agnostic** â€” meaning the same JPQL works across MySQL, PostgreSQL, Oracle, etc.
- Itâ€™s used in **repositories**, **custom queries**, and **dynamic query building**.

---

## ğŸ” JPQL vs SQL

| Feature         | JPQL                                | SQL                                 |
|----------------|--------------------------------------|-------------------------------------|
| Operates on    | Java entities                        | Database tables                     |
| Syntax         | Object-oriented                      | Table-oriented                      |
| Portability    | High (JPA standard)                  | Depends on DB vendor                |
| Example        | `SELECT u FROM User u`               | `SELECT * FROM users`               |

---

## ğŸ”§ JPQL Syntax Examples

### ğŸ”¹ Select All Users
```java
@Query("SELECT u FROM User u")
List<User> findAllUsers();
```

### ğŸ”¹ Filter by Field
```java
@Query("SELECT u FROM User u WHERE u.email = :email")
User findByEmail(@Param("email") String email);
```

### ğŸ”¹ Join with Another Entity
```java
@Query("SELECT o FROM Order o JOIN o.user u WHERE u.id = :userId")
List<Order> findOrdersByUserId(@Param("userId") Long userId);
```

### ğŸ”¹ Update Query
```java
@Modifying
@Query("UPDATE User u SET u.status = 'ACTIVE' WHERE u.id = :id")
void activateUser(@Param("id") Long id);
```

> ğŸ” Use `@Modifying` for update/delete queries, and enable transaction management.

---

## ğŸ§  Best Practices

- âœ… Use **named parameters** (`:param`) for clarity and safety
- âœ… Avoid native SQL unless absolutely necessary
- âœ… Use **entity relationships** (`@OneToMany`, `@ManyToOne`) for joins
- âœ… Combine with **Spring Data JPA** for clean repository interfaces


## ğŸ’¬ What Does â€œTreated as a Literal Stringâ€ Mean?

When you use JPQL with **parameter binding**, like this:

```java
@Query("SELECT u FROM User u WHERE u.username = :username")
```

and pass in:
```java
username = "' OR '1'='1"
```

Spring Data JPA internally uses a **PreparedStatement**, which means it doesnâ€™t **inject** the value directly into the query string. Instead, it sends the query like:

```sql
SELECT u FROM User u WHERE u.username = ?
```

and binds the value `' OR '1'='1` as a **literal string**, not as part of the SQL syntax.

---

## ğŸ” Why This Is Safe

- The database sees `' OR '1'='1` as just a weird username â€” not as a command to alter the query logic.
- It tries to find a user whose username is literally `' OR '1'='1`, which **doesnâ€™t exist**, so the query returns nothing.
- The dangerous part (`OR '1'='1'`) is **not executed** â€” itâ€™s just treated like any other string.

---

## ğŸ§ª Unsafe Version (for contrast)

If you did this:
```java
String query = "SELECT * FROM users WHERE username = '" + userInput + "'";
```

and `userInput = ' OR '1'='1`, the query becomes:
```sql
SELECT * FROM users WHERE username = '' OR '1'='1'
```

Now `'1'='1'` is **valid SQL logic**, so the query returns **all users** â€” thatâ€™s SQL injection.

---

## ğŸ§  Summary

| Input Type           | Behavior                          |
|----------------------|-----------------------------------|
| **Bound parameter**  | Treated as data (safe)            |
| **Concatenated string** | Treated as code (vulnerable)     |