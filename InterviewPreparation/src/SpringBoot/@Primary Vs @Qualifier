## ðŸ§­ The Problem
You have **multiple beans of the same type**, and Spring doesnâ€™t know which one to inject.
Thatâ€™s where `@Primary` and `@Qualifier` come in.

---

## ðŸ¥‡ `@Primary`: The Default Winner

### ðŸ”¹ What It Does
Marks a bean as the **default choice** when multiple candidates exist.

### ðŸ”¹ Example
```java
@Bean
@Primary
public Vehicle car() {
    return new Car();
}

@Bean
public Vehicle bike() {
    return new Bike();
}
```

### ðŸ”¹ Usage
```java
@Autowired
private Vehicle vehicle; // Injects Car because it's @Primary
```

---

## ðŸŽ¯ `@Qualifier`: The Explicit Selector

### ðŸ”¹ What It Does
Lets you **specify exactly** which bean to inject â€” overrides `@Primary`.

### ðŸ”¹ Example
```java
@Bean
public Vehicle car() {
    return new Car();
}

@Bean
public Vehicle bike() {
    return new Bike();
}
```

### ðŸ”¹ Usage
```java
@Autowired
@Qualifier("bike")
private Vehicle vehicle; // Injects Bike
```

---

## ðŸ§  When to Use What

| Use Case                          | Annotation     |
|----------------------------------|----------------|
| You want a **default bean**      | `@Primary`     |
| You need **fine-grained control**| `@Qualifier`   |
| You have **multiple beans** and want to switch based on context | `@Qualifier` |

---

## ðŸ’¡ Pro Tip
You can combine both:
- Use `@Primary` for the most common bean.
- Use `@Qualifier` when you need something specific.

---

Want to see how this plays out in a real-world scenario like injecting different payment gateways or
message senders? I can whip up a quick example for that too.
