A Trie (pronounced â€œtryâ€) is a tree-based data structure used for efficient prefix-based searching,
especially in dictionaries, autocomplete systems, and spell checkers. It's not part of Javaâ€™s
standard collections, but it's easy to implement and incredibly powerful.

ğŸŒ³ What Is a Trie?
- Each node represents a character
- Paths from root to leaf form words
- Common prefixes are shared, making it memory-efficient
- Supports fast insert, search, and prefix lookup in O(k) time, where k is the length of the word


ğŸ§  When to Use a Trie

| Use Case            | Why Trie Works Well             |
|---------------------|----------------------------------|
| Autocomplete         | Fast prefix lookup              |
| Spell checker        | Efficient word existence check  |
| Dictionary           | Shared prefixes save memory     |
| IP routing / DNS     | Hierarchical prefix matching    |



In most basic Trie implementations:

TrieNode[] children = new TrieNode[26]; // only supports 'a' to 'z'


This assumes all input is lowercase. If you insert `"Abhishek"` and `"abhishek"`, theyâ€™ll collide or be misindexed.

---

## âœ… Solution: Support Full Alphabet (Upper + Lower)

### Option 1: Use a `Map<Character, TrieNode>`
This is the **most flexible and scalable** approach.

```java
class TrieNode {
    Map<Character, TrieNode> children = new HashMap<>();
    boolean isEndOfWord = false;
}
```

### Benefits:
- Supports **all characters**: `Aâ€“Z`, `aâ€“z`, digits, symbols
- No need to calculate index manually
- Case-sensitive by default (you can normalize if needed)

---

## ğŸ”§ Updated Insert Method

```java
public void insert(String word) {
    TrieNode node = root;
    for (char ch : word.toCharArray()) {
        node.children.putIfAbsent(ch, new TrieNode());
        node = node.children.get(ch);
    }
    node.isEndOfWord = true;
}
```

---

## ğŸ§ª Example

```java
trie.insert("Abhishek");
trie.insert("abhishek");

System.out.println(trie.search("Abhishek")); // true
System.out.println(trie.search("abhishek")); // true
```

Theyâ€™re treated as **distinct words** unless you normalize case.

---

## ğŸ§¸ Optional: Normalize Case

If you want `"Abhishek"` and `"abhishek"` to be treated the same:
```java
word = word.toLowerCase(); // before inserting or searching
```

---

## ğŸ§  TL;DR

| Approach                     | Supports Aâ€“Z and aâ€“z? | Recommended? |
|-----------------------------|------------------------|--------------|
| `TrieNode[26]`              | âŒ Only lowercase       | âŒ Limited    |
| `Map<Character, TrieNode>`  | âœ… All characters       | âœ… Flexible   |


